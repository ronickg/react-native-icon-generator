import fs from "fs-extra";
import path from "path";
import { fileURLToPath } from "url";
import { Command } from "commander";
import svgson from "svgson";
import { optimize } from "svgo";
import svg2vectordrawable from "svg2vectordrawable";
import svgfixer from "oslllo-svg-fixer";

/

/ // Define CLI options and arguments
// program
//   .version("1.0.0")
//   .description("Convert SVG icons to Android and iOS formats")
//   .argument("<svgFiles...>", "One or more SVG files to convert")
//   .option("-o, --output <path>", "Output directory", "./output")
//   .option("--android", "Generate only Android vector drawables")
//   .option("--ios", "Generate only iOS symbol sets")
//   .option("--precision <n>", "Float precision for vector coordinates", "2")
//   .option(
//     "--tint <color>",
//     "Tint color for Android drawables",
//     "?attr/colorControlNormal"
//   )
//   .option("--continue-on-error", "Continue processing other files on error")
//   .option("--no-stroke-to-fill", "Skip converting strokes to fills")
//   .parse(process.argv);

// const options = program.opts();
// const svgFiles = program.args;
// const outputDir = path.resolve(options.output);

// // Ensure output directory exists
// fs.ensureDirSync(outputDir);

// // SVGO configuration to preserve necessary attributes
// const svgoConfig = {
//   plugins: [
//     {
//       name: "preset-default",
//       params: {
//         overrides: {
//           removeViewBox: false,
//           cleanupAttrs: true,
//         },
//       },
//     },
//     // Only add the convertStrokeToFill plugin if we're not using svg-fixer
//     ...(options.noStrokeToFill
//       ? [
//           {
//             name: "convertStrokeToFill",
//             fn: () => ({
//               element: {
//                 enter: (node: any) => {
//                   if (node.attributes.stroke && !node.attributes.fill) {
//                     node.attributes.fill = node.attributes.stroke;
//                     delete node.attributes.stroke;
//                     delete node.attributes["stroke-width"];
//                     delete node.attributes["stroke-linecap"];
//                     delete node.attributes["stroke-linejoin"];
//                   }
//                 },
//               },
//             }),
//           },
//         ]
//       : []),
//   ],
// };

// // iOS symbol set JSON template
// function createIosSymbolSetJson(fileName: string) {
//   return {
//     info: {
//       author: "xcode",
//       version: 1,
//     },
//     symbols: [
//       {
//         idiom: "universal",
//         filename: `${fileName}.svg`,
//       },
//     ],
//   };
// }

// // Fix SVG with svg-fixer (convert strokes to fills)
// async function fixSvgStrokes(
//   svgContent: string,
//   tempDir: string,
//   fileName: string
// ): Promise<string> {
//   const tempFile = path.join(tempDir, `${fileName}-temp.svg`);
//   const outputFile = path.join(tempDir, `${fileName}-fixed.svg`);

//   // Write the SVG content to a temporary file
//   await fs.writeFile(tempFile, svgContent, "utf8");

//   // Create temporary output directory
//   fs.ensureDirSync(path.dirname(outputFile));

//   // Fix the SVG using oslllo-svg-fixer
//   await svgfixer.fix(tempFile, path.dirname(outputFile), {
//     showProgressBar: false,
//   });

//   // Read the fixed SVG
//   const fixedSvg = await fs.readFile(outputFile, "utf8");

//   // Clean up temporary files
//   try {
//     await fs.remove(tempFile);
//     await fs.remove(outputFile);
//   } catch (error) {
//     // Ignore cleanup errors
//   }

//   return fixedSvg;
// }

// // Process each SVG file
// async function processSvgFile(svgFile: string) {
//   try {
//     const fileName = path.basename(svgFile, ".svg");
//     const svgContent = await fs.readFile(svgFile, "utf8");

//     let processedSvg = svgContent;

//     // Create a temp directory for processing
//     const tempDir = path.join(outputDir, "temp");
//     fs.ensureDirSync(tempDir);

//     // Step 1: Convert strokes to fills with svg-fixer if enabled
//     if (!options.noStrokeToFill) {
//       try {
//         processedSvg = await fixSvgStrokes(svgContent, tempDir, fileName);
//       } catch (fixError: any) {
//         console.warn(
//           `Warning: SVG Fixer failed for ${fileName}, falling back to basic optimization: ${fixError.message}`
//         );
//         // Fall back to original SVG if fixing fails
//         processedSvg = svgContent;
//       }
//     }

//     // Step 2: Optimize SVG with SVGO
//     const optimizedSvg = optimize(processedSvg, svgoConfig).data;
//     const svgJson = await svgson.parse(optimizedSvg);

//     // Step 3: Generate Android vector drawable if not iOS-only
//     if (!options.ios || options.android) {
//       const androidDir = path.join(outputDir, "android");
//       fs.ensureDirSync(androidDir);

//       // Use svg2vectordrawable instead of custom implementation
//       const vectorDrawableOptions = {
//         floatPrecision: parseInt(options.precision, 10),
//         fillBlack: false,
//         xmlTag: false,
//         tint: options.tint,
//       };

//       try {
//         const androidXml = await svg2vectordrawable(
//           optimizedSvg,
//           vectorDrawableOptions
//         );
//         await fs.writeFile(
//           path.join(androidDir, `${fileName}.xml`),
//           androidXml
//         );
//         console.log(`Generated Android drawable: ${fileName}.xml`);
//       } catch (vectorError: any) {
//         console.error(
//           `Error generating Android vector drawable for ${fileName}: ${vectorError.message}`
//         );
//         if (!options.continueOnError) {
//           throw vectorError;
//         }
//       }
//     }

//     // Step 4: Generate iOS symbol set if not Android-only
//     if (!options.android || options.ios) {
//       const iosDir = path.join(outputDir, "ios", `${fileName}.symbolset`);
//       fs.ensureDirSync(iosDir);

//       // Write SVG
//       const iosSvg = await svgson.stringify(svgJson);
//       await fs.writeFile(path.join(iosDir, `${fileName}.svg`), iosSvg);

//       // Write Contents.json
//       const iosJson = createIosSymbolSetJson(fileName);
//       await fs.writeFile(
//         path.join(iosDir, "Contents.json"),
//         JSON.stringify(iosJson, null, 2)
//       );
//       console.log(`Generated iOS symbol set: ${fileName}.symbolset`);
//     }

//     // Clean up temp directory
//     try {
//       await fs.remove(tempDir);
//     } catch (error) {
//       // Ignore cleanup errors
//     }
//   } catch (error: any) {
//     console.error(`Error processing ${svgFile}:`, error.message);
//     if (!options.continueOnError) {
//       process.exit(1);
//     }
//   }
// }

// // Process all SVG files
// (async () => {
//   for (const svgFile of svgFiles) {
//     if (!fs.existsSync(svgFile)) {
//       console.error(`File not found: ${svgFile}`);
//       if (!options.continueOnError) {
//         process.exit(1);
//       }
//       continue;
//     }
//     await processSvgFile(svgFile);
//   }
// })();
